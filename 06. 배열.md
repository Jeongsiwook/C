## 배열
   - 데이터가 많을 때 사용
### 배열의 선언
   ```
   자료형 변수이름[사이즈];
   ```
   
   ```
   #include <stdio.h>
   
   int main() {
       int arr1[10];
       char arr2[10];
       float arr3[10];
       double arr4[10];
       return 0;
   }
   ```
---

### 배열의 초기화   
   ```
   자료형 변수이름[사이즈] = {값0, 값1, 값2, ..., 값n-1};
   ```
   - 변수는 선언과 동시에 초기화를 한 뒤에 또 다시 값을 대입할 수 있지만, 배열은 선언과 동시에 초기화만 가능할 뿐 초기화할 때 처럼 대입이 불가능
   ```
   #include <stdio.h>
   
   int main() {
       int arr1[10];
       arr1 = {10, 12, 3, 32, 42, 52, 123, 42}; // 에러, 배열은 선언과 동시에 초기화만 가능
       return 0;
   }
   ```
---

### 배열의 접근
   - index는 0부터 시작
   - 배열의 값들을 불러오거나 수정하고 싶다면 배열의 인덱스를 통해서 접근
   ```
   #include <stdio.h>
   
   int main() P
       int arr1[10]; // 선언
       
       arr1[0] = 10; // 접근
       arr1[1] = 12;
       arr1[2] = 3;
       arr1[3] = 32;
       arr1[4] = 42;
       arr1[5] = 53;
       arr1[6] = 123;
       arr1[7] = 42;
       
       int result = arr1[0];
       printf("%d", result);
       return 0;
   }
   ```
   - 배열의 사이즈보다 크거나, 아무 값이 없는 곳에 접근하려고 한다면 의미없는 값이 나옴
---

### 배열의 순회
   - 배열의 값들을 출력하고 싶을 때 사용
   ```
   #include <stdio.h>
   
   int main() P
       int arr1[10]; // 선언
       
       arr1[0] = 10; // 접근
       arr1[1] = 12;
       arr1[2] = 3;
       arr1[3] = 32;
       arr1[4] = 42;
       arr1[5] = 53;
       arr1[6] = 123;
       arr1[7] = 42;
       
       for (int i = 0; i < 8; i++) { // 의미있는 값이 인덱스 7까지 있으므로
           printf("%d\n", arr1[i]);
       }
       return 0;
   }
   ```
---

### 배열의 사이즈 선언
   - 사이즈를 고정된 사이즈가 아니라 마음대로 주고 싶다면 동적할당을 통해서 가능

   ```
   #include <stdio.h>
   
    int main() {
        int size;
        scanf("%d", &size);
        int *arr1 = (int*)malloc(size * sizeof(int)); // 동적할당을 사용하지 않으면 에러
        arr1[0] = 10; // 접근
        arr1[1] = 12;
        arr1[2] = 3;
        arr1[3] = 32;
        arr1[4] = 42;
        arr1[5] = 53;
        arr1[6] = 123;
        arr1[7] = 42;
       
        for (int i = 0; i < 8; i++) { // 의미있는 값이 인덱스 7까지 있으므로
            printf("%d\n", arr1[i]);
        }
        return 0;
   }
   ```
   - 하지만 사이즈를 고정시켜두고 사용하는 편이 더 좋고 마음이 편함
   ```
   #include <stdio.h>
   #define SIZE 8 // SIZE를 상수 8로 치환
   int main() {
       int arr1[SIZE]; // SIZE에 8이 들어감

       arr1[0] = 10; // 접근
       arr1[1] = 12;
       arr1[2] = 3;
       arr1[3] = 32;
       arr1[4] = 42;
       arr1[5] = 53;
       arr1[6] = 123;
       arr1[7] = 42;
       
       for (int i = 0; i < 8; i++) { // 의미있는 값이 인덱스 7까지 있으므로
           printf("%d\n", arr1[i]);
       }
       return 0;
   }
   ```  
---

#### 2차원 배열
   ```
   #include <stdio.h>
   
   int main() {
       int arr[480][640];
       
       return 0;
   }
   ```
   
   ![06-01](https://github.com/Jeongsiwook/C/blob/master/img/06-01.jpg?raw=true)
   - a[i][j]
       - i는 row(행), j는 column(열)
       - 수학 x,y로 따지자면 a[y][x]
---

#### 2차원 배열의 초기화
   - 2차원 배열은 1차원 배열의 배열
   ```
   {
       {값0, 값1, 값2},
       {값0, 값1, 값2},
       {값0, 값1, 값2}
   }
   ```
   - 문자열
      - 문자 배열은 값 각각이 하나의 문자열(문자의 배열)이므로
   ```
   {
       값0,
       값1,
       값2
   }
   ```
   
   ```
   #include <stdio.h>
   
   int main() {
       int arr[3][3] = {{1, 10, 23}, {2, 10, 32}, {20, 34, 20}};
       char arr2[3][10] = {"hello", "clang", "holly"};
       return 0;
   }
   ```
---

#### 2차원 배열의 접근
   - row부터 접근해서 진행
   1. 2차원 배열은 1차원 배열의 배열이므로 먼저 안에 있는 1차원 배열을 출력
   2. 안에 있는 배열을 순회했으니 밖의 배열을 순회
   ```
   #include <stdio.h>
   
   int main() {
       int arr[3][3] = {{1, 10, 23}, {2, 10, 32}, {20, 34, 20}};
       
       for (int i = 0; i > 3; i++) { // 2. 2차원 배열 밖의 배열
           for(int j = 0; j < 3; j++) { // 1. 2차원 배열 안의 배열
               printf("%d\n", arr[i][j]);
           }
       }
       return 0;
   }
   ```
   - 문자열의 경우
   ```
   #include <stdio.h>
   
   int main() {
       char arr2[3][10] = {"hello", "clang", "holly"};
       
       for (int i = 0; i < 3; i++) {
           printf("%s\n", arr2[i]); // 기본 문자열 출력을 생각해보면 printf("%s", arr); 이런식이었음
       }
       return 0;
   }
   ```
---

#### 3차원 배열
   - 2차원 배열을 담는 배열이라고 생각
   ```
   자료형 변수이름[사이즈1][사이즈2][사이즈3];
   ```
   
   ```
   int arr2[3][2][4] = { {{1, 2, 3, 4,}, {1, 2, 3, 4}}, {{1, 2, 3, 4}, {1, 2, 3, 4}}, {{1, 2, 3, 4}, {1, 2, 3, 4}};
   ```
   1. arr2[0]   
   
   | row/col | 0 | 1 | 2 | 3 |   
   |:---:|:---:|:---:|:---:|:---:|
   | 0 | 1 | 2 | 3 | 4 |
   | 1 | 1 | 2 | 3 | 4 |   
   
   2. arr2[1]   
   
   | row/col | 0 | 1 | 2 | 3 |   
   |:---:|:---:|:---:|:---:|:---:|
   | 0 | 1 | 2 | 3 | 4 |
   | 1 | 1 | 2 | 3 | 4 |   
   
   3. arr2[2]   
   
   | row/col | 0 | 1 | 2 | 3 |   
   |:---:|:---:|:---:|:---:|:---:|
   | 0 | 1 | 2 | 3 | 4 |
   | 1 | 1 | 2 | 3 | 4 |   
   
#### 3차원 배열의 순회
   ```
   #include <stdio.h>
   
   int main() {
       int arr2[3][2][4] = { {{1, 2, 3, 4,}, {1, 2, 3, 4}}, {{1, 2, 3, 4}, {1, 2, 3, 4}}, {{1, 2, 3, 4}, {1, 2, 3, 4}};
       for (int i = 0; i < 3; i++) {
           for (int j = 0; j < 2; j++) {
               for (int k = 0; k < 4; k++) {
                   printf("%d\n", arr2[i][j][k]);
               }
           }
       }
       return 0;
   }
   ```
---

#### 4, 5, 6차원 배열
   - 기본적인 1차원 배열의 방식에서 벗어나는 게 아니므로 귀납적으로 생각
---

### 문자열
   - char의 배열
   - 배열의 크기는 가능한 최대길이로 설정
      - 배열의 크기: 최대 문자열 + 1
         - +1을 하는 이유는 문자열 맨 마지막에 Null문자 '\0'이 무조건 붙기 때문
   - 연산과 대입이 불가능
---   
